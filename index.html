<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Game Beta 12</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      position: relative;
    }

    #backgroundCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: -1;
    }

    canvas {
      display: block;
      margin: auto;
    }
    /* Adiciona regras de mídia para ajustar o tamanho do texto em dispositivos móveis */
    @media screen and (max-width: 600px) {
      canvas {
        font-size: 12px;
      }
      .message {
        font-size: 14px; /* Ajusta o tamanho do texto das mensagens */
      }
    }

    /* Estilo para o botão de reiniciar jogo */
    .restart-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      display: none;
    }

    .restart-button:hover {
      background-color: #45a049;
    }

    /* Estilo para o painel de score */
    .score-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 22px;
      border-radius: 0 0 10px 10px;
      font-family: 'Roboto', sans-serif;
      opacity: 1.0;
    }

    /* Estilo para o botão de pause e play */
    .pause-play-button {
      position: fixed;
      top: 5px;
      right: 10px;
      padding: 8px 15px;
      background-color: #008ab7;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }

    .pause-play-button:hover {
      background-color: #0fae4b;
    }

    /* Estilo para a imagem dos coletáveis especiais */
    #supplyImg {
      position: absolute;
      z-index: 1; /* Para garantir que os coletáveis fiquem acima do fundo */
    }

  </style>
</head>
<body>
  <canvas id="backgroundCanvas"></canvas>
  <canvas id="gameCanvas"></canvas>
  <button class="restart-button" onclick="restartGame()">Reiniciar Jogo</button>
  <div class="score-panel" id="scorePanel"></div>
  <button class="pause-play-button" onclick="togglePausePlay()">Pause</button>
  <audio id="completeSound" src="complete.wav"></audio>
  <img id="supplyImg" src="supply.png" style="display: none;">
  <script>
    const backgroundCanvas = document.getElementById('backgroundCanvas');
  const bgCtx = backgroundCanvas.getContext('2d');

  backgroundCanvas.width = window.innerWidth;
  backgroundCanvas.height = window.innerHeight;

  const backgroundImage = new Image();
  backgroundImage.src = 'space.png';

  let bgY = 0;
  let isPaused = false; // Variável para controlar o estado de pausa

  function drawBackground() {
    bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
    bgCtx.drawImage(backgroundImage, 0, bgY, backgroundCanvas.width, backgroundCanvas.height);
    bgCtx.drawImage(backgroundImage, 0, bgY - backgroundCanvas.height, backgroundCanvas.width, backgroundCanvas.height);
    bgY += 1; // Ajuste a velocidade aqui
    if (bgY >= backgroundCanvas.height) {
      bgY = 0;
    }
    if (!isPaused) {
      requestAnimationFrame(drawBackground);
    }
  }

  backgroundImage.onload = drawBackground;

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let shipImg = new Image();
  shipImg.src = 'nave.png';

  // Restante do código permanece inalterado
  // ...

  // Função para desenhar os coletáveis especiais e movê-los
  function drawSuppliesAndMove() {
    drawSupplies(); // Desenha os coletáveis especiais
    moveSupplies(); // Move os coletáveis especiais
  }

  supplyImg.onload = () => {
    draw(); // Chama a função draw() após a imagem dos coletáveis especiais ser carregada
  };

  // Adicione a função drawSupplies à função draw para desenhar os coletáveis
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!isPaused) { // Desenhar apenas se o jogo não estiver pausado
      drawShip();
      drawBullets();
      drawMeteors();
      drawScore();
      drawPhaseMessage();
      drawWinMessage();
      drawSuppliesAndMove(); // Desenha e move os coletáveis especiais
      moveShip();
      moveBullets();
      moveMeteors();
      checkCollisions();
      checkMeteorBottom();
      checkPhase();
    } else {
      ctx.fillStyle = 'white';
      ctx.font = '48px Arial';
      ctx.fillText('Jogo Pausado', canvas.width / 2 - 150, canvas.height / 2);
    }
    if (!isPaused) {
      requestAnimationFrame(draw);
    }
  }

  // Adicione a chamada para drawSuppliesAndMove à função draw para desenhar e mover os coletáveis
  function draw() {
    // ...
    drawSuppliesAndMove(); // Desenha e move os coletáveis especiais
    if (!isPaused) {
      requestAnimationFrame(draw);
    }
  }

  // Função para verificar a colisão da nave com os coletáveis
  function checkSupplyCollision() {
    supplies.forEach((supply, index) => {
      if (
        shipX < supply.x + 30 &&
        shipX + shipSize > supply.x &&
        shipY < supply.y + 30 &&
        shipY + shipSize > supply.y
      ) {
        // Se houver colisão, conceda uma vida ao jogador
        increaseLife();
        // Remova o coletável da lista
        supplies.splice(index, 1);
      }
    });
  }

  // Adicione a chamada para checkSupplyCollision na função checkCollisions
  function checkCollisions() {
    // ...
    bullets.forEach(bullet => {
      meteors.forEach((meteor, meteorIndex) => {
        if (bullet.x < meteor.x + meteor.width &&
          bullet.x + bulletWidth > meteor.x &&
          bullet.y < meteor.y + meteor.height &&
          bullet.y + bulletHeight > meteor.y) {
          bullets = bullets.filter(b => b !== bullet);
          score += getMeteorScore(meteor.color);
          drawExplosion(meteor.x + meteor.width / 2, meteor.y + meteor.height / 2);
          explosionSound.currentTime = 0; // Reinicia o áudio para evitar intervalos
          explosionSound.play(); // Toca o som da explosão
          meteors.splice(meteorIndex, 1);
        }
      });
    });
    checkSupplyCollision(); // Verifica a colisão com os coletáveis especiais
  }

  // ...
</script>
Com estas alterações, seu jogo deve ser

User
Talvez seja melhor você escrever o código JS completo do jogo para eu substituir tudo. Pode ser?
ChatGPT
Claro, aqui está o código JavaScript completo para o seu jogo, incluindo a integração das funcionalidades dos coletáveis especiais:

html
Copy code
<script>
  // Funções e variáveis para o fundo do jogo

  const backgroundCanvas = document.getElementById('backgroundCanvas');
  const bgCtx = backgroundCanvas.getContext('2d');

  backgroundCanvas.width = window.innerWidth;
  backgroundCanvas.height = window.innerHeight;

  const backgroundImage = new Image();
  backgroundImage.src = 'space.png';

  let bgY = 0;
  let isPaused = false; // Variável para controlar o estado de pausa

  function drawBackground() {
    bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
    bgCtx.drawImage(backgroundImage, 0, bgY, backgroundCanvas.width, backgroundCanvas.height);
    bgCtx.drawImage(backgroundImage, 0, bgY - backgroundCanvas.height, backgroundCanvas.width, backgroundCanvas.height);
    bgY += 1; // Ajuste a velocidade aqui
    if (bgY >= backgroundCanvas.height) {
      bgY = 0;
    }
    if (!isPaused) {
      requestAnimationFrame(drawBackground);
    }
  }

  backgroundImage.onload = drawBackground;

  // Funções e variáveis para a nave do jogador

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let shipImg = new Image();
  shipImg.src = 'nave.png';

  const shipSize = 75; // Aumento de 50% no tamanho da nave
  const shipSpeed = 5;
  let shipX = (canvas.width - shipSize) / 2;
  let shipY = canvas.height - shipSize - 10;
  let leftPressed = false;
  let rightPressed = false;
  let upPressed = false;
  let downPressed = false;

  // Funções e variáveis para os tiros

  const bulletWidth = 5;
  const bulletHeight = 15;
  const bulletSpeed = 5;
  let bullets = [];

  // Funções e variáveis para os meteoros

  const meteorImages = {
    yellow: 'rock1.png',
    green: 'rock2.png',
    red: 'rock3.png',
    blue: 'rock4.png',
    purple: 'rock5.png'
  };

  const yellowMeteorWidth = 30;
  const yellowMeteorHeight = 30;
  const greenMeteorWidth = 45;
  const greenMeteorHeight = 45;
  const redMeteorWidth = 60;
  const redMeteorHeight = 60;
  const blueMeteorWidth = 40;
  const blueMeteorHeight = 40;
  const purpleMeteorWidth = 50;
  const purpleMeteorHeight = 50;
  const meteorSpeed = 2;
  let meteors = [];

  // Funções e variáveis para o score e fases

  let score = 0;
  let phase = 1;
  let phaseMessage = '';
  let phaseStartTime = 0;
  let gameEnded = false;
  let lives = 3; // Vidas iniciais

  // Funções e variáveis para os sons

  let shootSound = new Audio('shoot.wav');
  let explosionSound = new Audio('bum.wav');
  let completeSound = new Audio('complete.wav');

  // Função para desenhar a nave do jogador

  function drawShip() {
    ctx.drawImage(shipImg, shipX, shipY, shipSize, shipSize);
  }

  // Função para desenhar os tiros

  function drawBullets() {
    ctx.fillStyle = 'red';
    bullets.forEach(bullet => {
      ctx.fillRect(bullet.x, bullet.y, bulletWidth, bulletHeight);
    });
  }

  // Função para desenhar os meteoros

  function drawMeteors() {
    meteors.forEach(meteor => {
      const meteorImg = new Image();
      meteorImg.src = meteorImages[meteor.color];
      ctx.drawImage(meteorImg, meteor.x, meteor.y, meteor.width, meteor.height);
    });
  }

  // Função para desenhar o score

  function drawScore() {
    const scorePanel = document.getElementById('scorePanel');
    scorePanel.textContent = `Score: ${score}`;
  }

  // Função para mover a nave do jogador

  function moveShip() {
    if (leftPressed && shipX > 0) {
      shipX -= shipSpeed;
    }
    if (rightPressed && shipX < canvas.width - shipSize) {
      shipX += shipSpeed;
    }
    if (upPressed && shipY > 0) {
      shipY -= shipSpeed;
    }
    if (downPressed && shipY < canvas.height - shipSize) {
      shipY += shipSpeed;
    }
  }

  // Função para mover os tiros

  function moveBullets() {
    bullets.forEach(bullet => {
      bullet.y -= bulletSpeed;
    });
    bullets = bullets.filter(bullet => bullet.y > 0);
  }

  // Função para mover os meteoros

  function moveMeteors() {
    meteors.forEach(meteor => {
      meteor.y += meteorSpeed;
    });
    meteors = meteors.filter(meteor => meteor.y < canvas.height);
  }

  // Função para desenhar uma mensagem de fase

  function drawPhaseMessage() {
    const phasePanel = document.getElementById('phasePanel');
    phasePanel.textContent = phaseMessage;
  }

  // Função para desenhar uma mensagem de vitória

  function drawWinMessage() {
    if (gameEnded && meteors.length === 0) {
      ctx.fillStyle = 'white';
      ctx.font = '48px Arial';
      ctx.fillText('Você venceu!', canvas.width / 2 - 150, canvas.height / 2);
    }
  }

  // Função para desenhar uma explosão

  function drawExplosion(x, y) {
    ctx.fillStyle = 'orange';
    ctx.beginPath();
    ctx.arc(x, y, 30, 0, Math.PI * 2);
    ctx.fill();
  }

  // Função para verificar a colisão entre tiros e meteoros

  function checkCollisions() {
    bullets.forEach(bullet => {
      meteors.forEach((meteor, meteorIndex) => {
        if (bullet.x < meteor.x + meteor.width &&
          bullet.x + bulletWidth > meteor.x &&
          bullet.y < meteor.y + meteor.height &&
          bullet.y + bulletHeight > meteor.y) {
          bullets = bullets.filter(b => b !== bullet);
          score += getMeteorScore(meteor.color);
          drawExplosion(meteor.x + meteor.width / 2, meteor.y + meteor.height / 2);
          explosionSound.currentTime = 0; // Reinicia o áudio para evitar intervalos
          explosionSound.play(); // Toca o som da explosão
          meteors.splice(meteorIndex, 1);
        }
      });
    });
  }

  // Função para verificar se algum meteoro chegou ao fim da tela

  function checkMeteorBottom() {
    meteors.forEach((meteor, meteorIndex) => {
      if (meteor.y + meteor.height > canvas.height) {
        meteors.splice(meteorIndex, 1);
        loseLife(); // Reduz uma vida ao jogador
      }
    });
  }

  // Função para verificar a fase atual do jogo

  function checkPhase() {
    if (phaseMessage !== '') {
      const currentTime = new Date().getTime();
      if (currentTime - phaseStartTime >= 3000) { // Tempo da mensagem da fase
        phaseMessage = '';
      }
    } else {
      if (meteors.length === 0) {
        phase++;
        startPhase();
      }
    }
  }

  // Função para iniciar uma nova fase

  function startPhase() {
    phaseMessage = `Fase ${phase}`;
    phaseStartTime = new Date().getTime();
    generateMeteors(phase);
    completeSound.currentTime = 0; // Reinicia o áudio para evitar intervalos
    completeSound.play(); // Toca o som de conclusão da fase
  }

  // Função para gerar meteoros com base na fase atual

  function generateMeteors(phase) {
    const numMeteors = 5 + phase * 2; // Aumenta o número de meteoros com a fase
    for (let i = 0; i < numMeteors; i++) {
      const color = getRandomMeteorColor();
      const width = getMeteorWidth(color);
      const height = getMeteorHeight(color);
      const x = Math.random() * (canvas.width - width);
      const y = Math.random() * -canvas.height;
      meteors.push({ x, y, color, width, height });
    }
  }

  // Função para obter uma cor aleatória para os meteoros

  function getRandomMeteorColor() {
    const colors = Object.keys(meteorImages);
    return colors[Math.floor(Math.random() * colors.length)];
  }

  // Função para obter a largura de um meteoro com base na cor

  function getMeteorWidth(color) {
    switch (color) {
      case 'yellow':
        return yellowMeteorWidth;
      case 'green':
        return greenMeteorWidth;
      case 'red':
        return redMeteorWidth;
      case 'blue':
        return blueMeteorWidth;
      case 'purple':
        return purpleMeteorWidth;
    }
  }

  // Função para obter a altura de um meteoro com base na cor

  function getMeteorHeight(color) {
    switch (color) {
      case 'yellow':
        return yellowMeteorHeight;
      case 'green':
        return greenMeteorHeight;
      case 'red':
        return redMeteorHeight;
      case 'blue':
        return blueMeteorHeight;
      case 'purple':
        return purpleMeteorHeight;
    }
  }

  // Função para obter a pontuação de um meteoro com base na cor

  function getMeteorScore(color) {
    switch (color) {
      case 'yellow':
        return 5;
      case 'green':
        return 10;
      case 'red':
        return 15;
      case 'blue':
        return 20;
      case 'purple':
        return 25;
    }
  }

  // Função para controlar a lógica quando o jogador perde uma vida

  function loseLife() {
    lives--;
    if (lives <= 0) {
      gameOver();
    }
  }

  // Função para controlar a lógica quando o jogador ganha o jogo

  function gameOver() {
    gameEnded = true;
    ctx.fillStyle = 'white';
    ctx.font = '48px Arial';
    ctx.fillText('Game Over', canvas.width / 2 - 150, canvas.height / 2);
  }

  // Função para aumentar uma vida ao jogador

  function increaseLife() {
    lives++;
  }

  // Função para desenhar os coletáveis especiais

  function drawSupplies() {
    ctx.fillStyle = 'gold';
    supplies.forEach(supply => {
      ctx.fillRect(supply.x, supply.y, 30, 30);
    });
  }

  // Função para mover os coletáveis especiais

  function moveSupplies() {
    supplies.forEach(supply => {
      supply.y += 1; // Ajuste a velocidade aqui
    });
    supplies = supplies.filter(supply => supply.y < canvas.height);
  }

  // Função para verificar a colisão da nave com os coletáveis especiais

  function checkSupplyCollision() {
    supplies.forEach((supply, index) => {
      if (
        shipX < supply.x + 30 &&
        shipX + shipSize > supply.x &&
        shipY < supply.y + 30 &&
        shipY + shipSize > supply.y
      ) {
        // Se houver colisão, conceda uma vida ao jogador
        increaseLife();
        // Remova o coletável da lista
        supplies.splice(index, 1);
      }
    });
  }

  // Função principal para desenhar e controlar o jogo

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!isPaused) { // Desenhar apenas se o jogo não estiver pausado
      drawShip();
      drawBullets();
      drawMeteors();
      drawScore();
      drawPhaseMessage();
      drawWinMessage();
      drawSupplies(); // Desenha os coletáveis especiais
      moveShip();
      moveBullets();
      moveMeteors();
      checkCollisions();
      checkMeteorBottom();
      checkPhase();
      checkSupplyCollision(); // Verifica a colisão com os coletáveis especiais
    } else {
      ctx.fillStyle = 'white';
      ctx.font = '48px Arial';
      ctx.fillText('Jogo Pausado', canvas.width / 2 - 150, canvas.height / 2);
    }
    if (!gameEnded && !isPaused) {
      requestAnimationFrame(draw);
    }
  }

  // Funções para controlar os eventos do teclado

  document.addEventListener('keydown', keyDownHandler, false);
  document.addEventListener('keyup', keyUpHandler, false);

  function keyDownHandler(e) {
    if (e.key === 'Left' || e.key === 'ArrowLeft') {
      leftPressed = true;
    } else if (e.key === 'Right' || e.key === 'ArrowRight') {
      rightPressed = true;
    } else if (e.key === 'Up' || e.key === 'ArrowUp') {
      upPressed = true;
    } else if (e.key === 'Down' || e.key === 'ArrowDown') {
      downPressed = true;
    } else if (e.key === ' ' && !gameEnded) {
      shoot();
    } else if (e.key === 'Escape') {
      togglePause();
    }
  }

  function keyUpHandler(e) {
    if (e.key === 'Left' || e.key === 'ArrowLeft') {
      leftPressed = false;
    } else if (e.key === 'Right' || e.key === 'ArrowRight') {
      rightPressed = false;
    } else if (e.key === 'Up' || e.key === 'ArrowUp') {
      upPressed = false;
    } else if (e.key === 'Down' || e.key === 'ArrowDown') {
      downPressed = false;
    }
  }

  // Função para atirar

  function shoot() {
    const bulletX = shipX + (shipSize / 2) - (bulletWidth / 2);
    const bulletY = shipY;
    bullets.push({ x: bulletX, y: bulletY });
    shootSound.currentTime = 0; // Reinicia o áudio para evitar intervalos
    shootSound.play(); // Toca o som de tiro
  }

  // Função para pausar o jogo

  function togglePause() {
    isPaused = !isPaused;
    if (!gameEnded) {
      if (!isPaused) {
        draw(); // Reinicia o jogo se ele não estiver pausado
      }
    }
  }

  // Início do jogo

  startPhase(); // Inicia a primeira fase
  draw(); // Inicia o loop principal de desenho do jogo

  </script>
</body>
</html>
