<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Game Beta 12</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      position: relative;
    }

    #backgroundCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: -1;
    }

    canvas {
      display: block;
      margin: auto;
    }
    /* Adiciona regras de mídia para ajustar o tamanho do texto em dispositivos móveis */
    @media screen and (max-width: 600px) {
      canvas {
        font-size: 12px;
      }
      .message {
        font-size: 14px; /* Ajusta o tamanho do texto das mensagens */
      }
    }

    /* Estilo para o botão de reiniciar jogo */
    .restart-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      display: none;
    }

    .restart-button:hover {
      background-color: #45a049;
    }

    /* Estilo para o painel de score */
    .score-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 22px;
      border-radius: 0 0 10px 10px;
      font-family: 'Roboto', sans-serif;
      opacity: 1.0;
    }

    /* Estilo para o botão de pause e play */
    .pause-play-button {
      position: fixed;
      top: 5px;
      right: 10px;
      padding: 8px 15px;
      background-color: #008ab7;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }

    .pause-play-button:hover {
      background-color: #0fae4b;
    }

    #startButton {
     position: fixed;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     padding: 10px 20px;
     font-size: 20px;
     color: white;
     background-color: #4CAF50;
     border: none;
     border-radius: 5px;
     cursor: pointer;
   }

  </style>
</head>
<body>
  <canvas id="backgroundCanvas"></canvas>
  <canvas id="gameCanvas"></canvas>
  <button class="restart-button" onclick="restartGame()">Reiniciar Jogo</button>
  <div class="score-panel" id="scorePanel"></div>
  <button class="pause-play-button" onclick="togglePausePlay()">Pause</button>
  <button id="startButton">Iniciar Jogo</button>
  <audio id="backgroundMusic" src="mission.mp3" loop autoplay></audio>
  <audio id="completeSound" src="complete.wav"></audio>
  <script>
     document.getElementById('startButton').addEventListener('click', function() {
  this.style.display = 'none';
  if (!animationRunning) {
    startGame(); // Começa o jogo somente se não estiver já em execução
  }
});

let animationRunning = false;

function startGame() {
  animationRunning = true;
  gameLoop(); // Garante que o loop principal do jogo continue após iniciar
}

const backgroundCanvas = document.getElementById('backgroundCanvas');
const gameCanvas = document.getElementById('gameCanvas');
const bgCtx = backgroundCanvas.getContext('2d');
const ctx = gameCanvas.getContext('2d');

backgroundCanvas.width = gameCanvas.width = window.innerWidth;
backgroundCanvas.height = gameCanvas.height = window.innerHeight;

const backgroundImage = new Image();
const shipImage = new Image();

backgroundImage.src = 'space.png';
shipImage.src = 'nave.png';

backgroundImage.onload = function() {
  bgCtx.drawImage(backgroundImage, 0, 0, backgroundCanvas.width, backgroundCanvas.height);
};

shipImage.onload = function() {
  ctx.drawImage(shipImage, gameCanvas.width / 2 - 50, gameCanvas.height - 150, 100, 100); // Adjust position and size as needed
};

let bgY = 0;
let shipX = gameCanvas.width / 2;
let shipY = gameCanvas.height - 100;
let isPaused = false; // Variable to control pause state

document.addEventListener('DOMContentLoaded', function() {
  const backgroundMusic = document.getElementById('backgroundMusic');
  backgroundMusic.play();
  drawBackground(); // Start background animation once the page is loaded
});

let animationFrameId;

function drawBackground() {
  bgCtx.drawImage(backgroundImage, 0, bgY, backgroundCanvas.width, backgroundCanvas.height);
  bgCtx.drawImage(backgroundImage, 0, bgY - backgroundCanvas.height, backgroundCanvas.width, backgroundCanvas.height);
  bgY += 1;
  if (bgY >= backgroundCanvas.height) bgY = 0;
}

const shipSize = 75; // Increase ship size by 50%
const shipSpeed = 4;
let leftPressed = false;
let rightPressed = false;
let upPressed = false;
let downPressed = false;

const bulletWidth = 5;
const bulletHeight = 15;
const bulletSpeed = 4;
let bullets = [];

    const meteorImages = {
  yellow: 'rock1.png',
  green: 'rock2.png',
  red: 'rock3.png',
  blue: 'rock4.png',
  purple: 'rock5.png'
};

const yellowMeteorWidth = 30;
const yellowMeteorHeight = 30;
const greenMeteorWidth = 45;
const greenMeteorHeight = 45;
const redMeteorWidth = 60;
const redMeteorHeight = 60;
const blueMeteorWidth = 40;
const blueMeteorHeight = 40;
const purpleMeteorWidth = 50;
const purpleMeteorHeight = 50;
const meteorSpeed = 2;
let meteors = [];

let score = 0;
let phase = 1;
let phaseMessage = '';
let phaseStartTime = 0;
let gameEnded = false;
let lives = 3; // Initial lives

let shootSound = new Audio('shoot.wav');
let explosionSound = new Audio('bum.wav');
let completeSound = new Audio('complete.wav');

function draw() {
  ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
  if (!isPaused) {
    drawShip();
    drawBullets();
    drawMeteors();
    drawScore();
    drawPhaseMessage();
    drawWinMessage();
    moveShip();
    moveBullets();
    moveMeteors();
    checkCollisions();
    checkMeteorBottom();
    checkPhase();
  } else {
    displayPauseMessage();
  }
  animationFrameId = requestAnimationFrame(draw);
}
    
function togglePausePlay() {
  isPaused = !isPaused;
  const pausePlayButton = document.querySelector('.pause-play-button');
  pausePlayButton.textContent = isPaused ? 'Play' : 'Pause';
  if (isPaused) {
    cancelAnimationFrame(animationFrameId); // Para a animação
  } else if (!animationRunning) {
    startGame(); // Reinicia a animação de forma controlada se não estiver rodando
  }
}

function drawShip() {
  ctx.drawImage(shipImage, shipX - 50, shipY - 50, 100, 100); // Center the ship based on its size
}

function drawBullets() {
  ctx.fillStyle = 'red';
  bullets.forEach(bullet => {
    ctx.fillRect(bullet.x, bullet.y, bulletWidth, bulletHeight);
  });
}

function drawMeteors() {
  meteors.forEach(meteor => {
    const meteorImg = new Image();
    meteorImg.src = meteorImages[meteor.color];
    ctx.drawImage(meteorImg, meteor.x, meteor.y, meteor.width, meteor.height);
  });
}

function drawScore() {
  const scorePanel = document.getElementById('scorePanel');
  scorePanel.textContent = `Score: ${score}`;
}

function moveShip() {
  if (leftPressed && shipX > 0) {
    shipX -= shipSpeed;
  }
  if (rightPressed && shipX < gameCanvas.width - 100) {
    shipX += shipSpeed;
  }
  if (upPressed && shipY > 0) {
    shipY -= shipSpeed;
  }
  if (downPressed && shipY < gameCanvas.height - 100) {
    shipY += shipSpeed;
  }
}

function gameLoop() {
  if (!animationRunning) return;
  draw();
  requestAnimationFrame(gameLoop);
}

function moveBullets() {
  bullets.forEach(bullet => {
    bullet.y -= bulletSpeed;
  });
  bullets = bullets.filter(bullet => bullet.y > 0);
}

function moveMeteors() {
  meteors.forEach(meteor => {
    meteor.y += meteorSpeed;
  });
  meteors = meteors.filter(meteor => meteor.y < gameCanvas.height);
}

function checkCollisions() {
  bullets.forEach(bullet => {
    meteors.forEach((meteor, meteorIndex) => {
      if (bullet.x < meteor.x + meteor.width &&
          bullet.x + bulletWidth > meteor.x &&
          bullet.y < meteor.y + meteor.height &&
          bullet.y + bulletHeight > meteor.y) {
        bullets = bullets.filter(b => b !== bullet);
        score += getMeteorScore(meteor.color);
        drawExplosion(meteor.x + meteor.width / 2, meteor.y + meteor.height / 2);
        explosionSound.currentTime = 0; // Restart the audio to avoid intervals
        explosionSound.play(); // Play the explosion sound
        meteors.splice(meteorIndex, 1);
      }
    });
  });
}

function checkMeteorBottom() {
  meteors.forEach((meteor, meteorIndex) => {
    if (meteor.y + meteor.height >= gameCanvas.height) {
      score -= 5; // Subtract 5 points when a meteor reaches the bottom
      drawExplosion(meteor.x + meteor.width / 2, meteor.y + meteor.height / 2);
      explosionSound.currentTime = 0;
      explosionSound.play();
      meteors.splice(meteorIndex, 1);
    }
  });
}

function checkPhase() {
  if (score >= 1000 && phase === 1) {
    phase = 2;
    phaseMessage = 'Fase 2';
    phaseStartTime = Date.now();
    increaseLife(); // Increase life when advancing to the next phase
    playCompleteSound(); // Play phase transition music
  }
  // Add more conditions for other phases here
}

function playCompleteSound() {
  completeSound.currentTime = 0;
  completeSound.play();
}

function increaseLife() {
  lives++; // Increment life
}

function drawPhaseMessage() {
  ctx.fillStyle = 'white';
  ctx.font = '48px Arial';
  const messageWidth = ctx.measureText(phaseMessage).width;
  const messageX = (gameCanvas.width - messageWidth) / 2;
  ctx.fillText(phaseMessage, messageX, gameCanvas.height / 2);
}

function drawCountdown(countdown) {
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.fillText(`Next phase in ${countdown}...`, gameCanvas.width / 2 - 100, gameCanvas.height / 2 + 50);
}

function drawWinMessage() {
  if (score >= 5000 && phase === 3 && gameEnded) {
    // Draw a button to restart the game
    const restartButton = document.querySelector('.restart-button');
    restartButton.style.display = 'block';
  }
}

function getMeteorScore(color) {
  switch(color) {
    case 'yellow': return 10;
    case 'green': return 20;
    case 'red': return 30;
    case 'blue': return 50;
    case 'purple': return 100;
    default: return 0;
  }
}

function drawExplosion(x, y) {
  const explosionRadius = 50;
  const explosionGradient = ctx.createRadialGradient(x, y, 0, x, y, explosionRadius);
  explosionGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
  explosionGradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.5)');
  explosionGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
  ctx.fillStyle = explosionGradient;
  ctx.beginPath();
  ctx.arc(x, y, explosionRadius, 0, Math.PI * 2);
  ctx.fill();
}

function createMeteor() {
  let x, y, color, width, height;
  x = Math.random() * (gameCanvas.width - yellowMeteorWidth);
  y = -yellowMeteorHeight;
  const colors = ['yellow', 'green', 'red', 'blue', 'purple'];
  color = colors[Math.floor(Math.random() * colors.length)];
  switch(color) {
    case 'yellow':
      width = yellowMeteorWidth;
      height = yellowMeteorHeight;
      break;
    case 'green':
      width = greenMeteorWidth;
      height = greenMeteorHeight;
      break;
    case 'red':
      width = redMeteorWidth;
      height = redMeteorHeight;
      break;
    case 'blue':
      width = blueMeteorWidth;
      height = blueMeteorHeight;
      break;
    case 'purple':
      width = purpleMeteorWidth;
      height = purpleMeteorHeight;
      break;
  }
  meteors.push({ x, y, color, width, height });
}

setInterval(createMeteor, 1000);

draw(); // Start drawing the game immediately

function handleTouch(event) {
  event.preventDefault();
  const touch = event.touches[0];
  const touchX = touch.clientX;
  const touchY = touch.clientY;

  // Determine the direction of movement based on the touch
  if (touchX < gameCanvas.width / 3 && touchY < gameCanvas.height / 3) {
    upPressed = true;
    leftPressed = true;
  } else if (touchX > gameCanvas.width / 3 && touchX < (2 * gameCanvas.width) / 3 && touchY < gameCanvas.height / 3) {
    upPressed = true;
  } else if (touchX > (2 * gameCanvas.width) / 3 && touchY < gameCanvas.height / 3) {
    upPressed = true;
    rightPressed = true;
  } else if (touchX < gameCanvas.width / 3 && touchY > gameCanvas.height / 3 && touchY < (2 * gameCanvas.height) / 3) {
    leftPressed = true;
  } else if (touchX > (2 * gameCanvas.width) / 3 && touchY > gameCanvas.height / 3 && touchY < (2 * gameCanvas.height) / 3) {
    rightPressed = true;
  } else if (touchX < gameCanvas.width / 3 && touchY > (2 * gameCanvas.height) / 3) {
    downPressed = true;
    leftPressed = true;
  } else if (touchX > gameCanvas.width / 3 && touchX < (2 * gameCanvas.width) / 3 && touchY > (2 * gameCanvas.height) / 3) {
    downPressed = true;
  } else if (touchX > (2 * gameCanvas.width) / 3 && touchY > (2 * gameCanvas.height) / 3) {
    downPressed = true;
    rightPressed = true;
  }

  // Add a shot when touching the screen
  bullets.push({ x: shipX + (shipSize / 2) - (bulletWidth / 2), y: shipY });
  shootSound.currentTime = 0;
  shootSound.play();
}

// Function to handle the end of a touch on the screen
function handleTouchEnd(event) {
  event.preventDefault();
  leftPressed = false;
  rightPressed = false;
  upPressed = false;
  downPressed = false;
}

// Add event listeners for touch on the screen
gameCanvas.addEventListener('touchstart', handleTouch);
gameCanvas.addEventListener('touchend', handleTouchEnd);

document.addEventListener('keydown', function(e) {
  if (e.key === 'ArrowLeft' || e.key === 'Left') {
    leftPressed = true;
  }
  if (e.key === 'ArrowRight' || e.key === 'Right') {
    rightPressed = true;
  }
  if (e.key === 'ArrowUp' || e.key === 'Up') {
    upPressed = true;
  }
  if (e.key === 'ArrowDown' || e.key === 'Down') {
    downPressed = true;
  }
});

document.addEventListener('keyup', function(e) {
  if (!isPaused) { // Check if the game is not paused
    if (e.key === 'ArrowLeft' || e.key === 'Left') {
      leftPressed = false;
    }
    if (e.key === 'ArrowRight' || e.key === 'Right') {
      rightPressed = false;
    }
    if (e.key === 'ArrowUp' || e.key === 'Up') {
      upPressed = false;
    }
    if (e.key === 'ArrowDown' || e.key === 'Down') {
      downPressed = false;
    }
    if (e.key === ' ' || e.key === 'Spacebar') {
      // Add a new shot to the list of bullets
      bullets.push({ x: shipX + (shipSize / 2) - (bulletWidth / 2), y: shipY });
      // Restart the audio to avoid intervals
      shootSound.currentTime = 0;
      // Play the shooting sound
      shootSound.play();
    }
  }
});

gameCanvas.addEventListener('click', function(event) {
  const clickX = event.clientX;
  const clickY = event.clientY;
  if (score >= 5000 && phase === 3 && gameEnded) {
    // Check if the click was on the restart game button
    const buttonX = gameCanvas.width / 2 - 100;
    const buttonY = gameCanvas.height / 2 + 100;
    if (clickX >= buttonX && clickX <= buttonX + 200 && clickY >= buttonY && clickY <= buttonY + 50) {
      restartGame();
      return;
    }
  }
  bullets.push({ x: shipX + (shipSize / 2) - (bulletWidth / 2), y: shipY });
  shootSound.currentTime = 0; // Restart the audio to avoid intervals
  shootSound.play(); // Play the shooting sound
});

function restartGame() {
  // Reset game variables
  score = 0;
  phase = 1;
  phaseMessage = '';
  phaseStartTime = 0;
  gameEnded = false;
  lives = 3;
  bullets = [];
  meteors = [];
  const restartButton = document.querySelector('.restart-button');
  restartButton.style.display = 'none';
}
  </script>
</body>
</html>
